// ▎1. ТЗ для консольного приложения

// ▎Техническое задание: "Демонстратор контекста this в JavaScript"

// Цель проекта: Создать консольное приложение, демонстрирующее различные аспекты работы с контекстом this в JavaScript и особенности преобразования объектов.

// Функциональные требования:

// 1. Модуль демонстрации контекста this:
//    - Демонстрация работы this в различных контекстах (глобальный контекст, объекты, функции, стрелочные функции)
//    - Примеры "потери" контекста и способы его сохранения
//    - Интерактивные примеры с геттерами/сеттерами

// 2. Модуль преобразования объектов:
//    - Реализация объектов с переопределенными методами преобразования типов
//    - Демонстрация работы объектов, которые при преобразовании равны числу или строке
//    - Примеры объектов с кастомной логикой сравнения (больше/меньше)

// 3. Интерактивный режим:
//    - Пользовательское меню для выбора демонстрации различных концепций
//    - Возможность ввода собственных примеров для проверки понимания

// 4. Режим тестирования знаний:
//    - Набор вопросов для самопроверки по темам контекста this и преобразования объектов
//    - Проверка ответов и вывод правильных решений с пояснениями

// Технические требования:
// - Использовать только нативный JavaScript (Node.js)
// - Не использовать внешние библиотеки
// - Структурировать код с использованием модулей
// - Обеспечить подробные комментарии, объясняющие каждый пример

// Результат проекта:
// Консольное приложение, которое можно использовать как для обучения, так и для демонстрации понимания концепций контекста this и преобразования объектов в JavaScript.







// ==================▎2. Вопросы и ответы для рекрутера================

// ▎Вопрос 1: Что такое this в JavaScript и как определяется его значение?
// Ответ: this - это ключевое слово, которое ссылается на контекст выполнения функции. Значение this определяется не во время объявления функции, а во время её вызова и зависит от способа вызова:
// - При обычном вызове функции this указывает на глобальный объект (в строгом режиме - undefined)
// - При вызове как метода объекта this указывает на этот объект
// - При вызове с new this указывает на новый созданный объект
// - При использовании методов call, apply или bind значение this явно задаётся первым аргументом

// ▎Вопрос 2: Что такое "потеря контекста" и в каких случаях она происходит?
// Ответ: "Потеря контекста" происходит, когда метод объекта передаётся как колбэк и вызывается отдельно от объекта. Например:
// const user = {
//   name: "John",
//   greet() { console.log(Hello, ${this.name}); }
// };

// setTimeout(user.greet, 1000); // "Hello, undefined" - контекст потерян

// Это происходит потому, что функция вызывается не как метод объекта, а как обычная функция, и this указывает на глобальный объект.

// ▎Вопрос 3: Какие существуют способы сохранения контекста this?
// Ответ: Основные способы:
// 1. Использование bind: setTimeout(user.greet.bind(user), 1000)
// 2. Использование стрелочных функций: setTimeout(() => user.greet(), 1000)
// 3. Сохранение this в переменную: 
// const self = this;
// function callback() { self.method(); }

// 4. Использование замыкания: 
// function outer() {
//   const that = this;
//   return function inner() {
//     that.method();
//   };
// }


// ▎Вопрос 4: Чему равен this внутри стрелочной функции?
// Ответ: Стрелочные функции не имеют собственного this. Они наследуют this из внешнего лексического окружения, в котором они были определены. Это делает их удобными для использования в качестве колбэков, когда нужно сохранить контекст.

// ▎Вопрос 5: Как работает this в геттерах и сеттерах объекта?
// Ответ: В геттерах и сеттерах объекта this указывает на объект, к которому применяется операция доступа к свойству. Например:
// const obj = {
//   _value: 0,
//   get value() {
//     return this._value;
//   },
//   set value(newValue) {
//     this._value = newValue;
//   }
// };

// При вызове obj.value или obj.value = 5, this внутри геттера или сеттера будет указывать на obj.

// Анна ., [14.04.2025 20:10]
// ▎Вопрос 6: Как реализовать объект, который при преобразовании в число возвращает определённое значение?
// Ответ: Нужно переопределить метод valueOf:
// const obj = {
//   valueOf() {
//     return 42;
//   }
// };
// console.log(Number(obj)); // 42
// console.log(obj == 42);   // true


// ▎Вопрос 7: Как реализовать объект, который при преобразовании в строку возвращает определённое значение?
// Ответ: Нужно переопределить метод toString:
// const obj = {
//   toString() {
//     return "Hello";
//   }
// };
// console.log(String(obj)); // "Hello"
// console.log(obj + "");    // "Hello"


// ▎Вопрос 8: Как реализовать объект, для которого выражение obj > 0 возвращает true?
// Ответ: Нужно переопределить метод valueOf, чтобы объект преобразовывался в число больше 0:
// const obj = {
//   valueOf() {
//     return 1; // любое положительное число
//   }
// };
// console.log(obj > 0); // true


// ▎Вопрос 9: Какой порядок вызова методов при преобразовании объекта в примитив?
// Ответ: Порядок зависит от "хинта" (подсказки) преобразования:
// - Для числового преобразования: сначала valueOf(), затем toString()
// - Для строкового преобразования: сначала toString(), затем valueOf()
// - Для "по умолчанию" (используется в большинстве операторов): как для числового в современных браузерах

// ▎Вопрос 10: Как работает метод bind и чем он отличается от call и apply?
// Ответ: 
// - bind(thisArg, arg1, arg2, ...) создаёт новую функцию с привязанным контекстом thisArg и, опционально, предустановленными аргументами. Не вызывает функцию сразу.
// - call(thisArg, arg1, arg2, ...) сразу вызывает функцию с контекстом thisArg и перечисленными аргументами.
// - apply(thisArg, [arg1, arg2, ...]) сразу вызывает функцию с контекстом thisArg и аргументами из массива.


// ==================▎2. Вопросы и ответы для рекрутера================

// ================▎3. Задачи от простого к сложному================

// ▎Задача 1: Определение значения this
// Что выведет каждый вызов и почему?
function showThis() {
  console.log(this);
}

const obj = { method: showThis };

showThis();
obj.method();
new showThis();


// Решение:
// // В обычном вызове this будет глобальным объектом (window в браузере, global в Node.js)
// // В строгом режиме будет undefined
// showThis(); // window или global (или undefined в строгом режиме)

// // При вызове как метода объекта this указывает на этот объект
// obj.method(); // { method: [Function: showThis] }

// // При вызове с new this указывает на новый созданный объект
// new showThis(); // showThis {}


// ▎Задача 2: Потеря контекста
const user9 = {
  name: "Alice",
  sayHi() {
    console.log(`Hi, I'm ${this.name}`);
  }
};

// Как исправить потерю контекста в каждом случае?
setTimeout(user9.sayHi, 1000);

const greet = user9.sayHi;
greet();


// Решение:
// // Вариант 1: Использование bind
// setTimeout(user.sayHi.bind(user), 1000);

// // Вариант 2: Использование стрелочной функции
// setTimeout(() => user.sayHi(), 1000);

// // Для второго случая:
// const greet = user.sayHi.bind(user);
// greet(); // "Hi, I'm Alice"

// // Или
// const greet2 = () => user.sayHi();
// greet2(); // "Hi, I'm Alice"


// ▎Задача 3: Работа с геттерами и сеттерами
// Создайте объект счетчика с геттером и сеттером,
// который не позволяет установить отрицательное значение

const counter = {
  // Ваш код
};

console.log(counter.value); // Должно вывести 0
counter.value = 10;
console.log(counter.value); // Должно вывести 10
counter.value = -5;
console.log(counter.value); // Должно остаться 10


// Решение:
// const counter = {
//   _value: 0,
//   get value() {
//     return this._value;
//   },
//   set value(newValue) {
//     if (newValue >= 0) {
//       this._value = newValue;
//     }
//   }
// };

// console.log(counter.value); // 0
// counter.value = 10;
// console.log(counter.value); // 10
// counter.value = -5;
// console.log(counter.value); // 10 (не изменилось)


// ▎Задача 4: Стрелочные функции и this
// Исправьте код, чтобы он работал корректно

const group = {
  title: "JavaScript Group",
  students: ["John", "Jane", "Alice"],
  showList() {
    this.students.forEach(function(student) {


      console.log(`${this.title}: ${student}`);
    });
  }
};

group.showList();


// Решение:
// const group = {
//   title: "JavaScript Group",
//   students: ["John", "Jane", "Alice"],
//   showList() {
//     // Вариант 1: Использование стрелочной функции
//     this.students.forEach(student => {
//       console.log(${this.title}: ${student});
//     });
    
//     // Вариант 2: Использование bind
//     /*
//     this.students.forEach(function(student) {
//       console.log(${this.title}: ${student});
//     }.bind(this));
//     */
    
//     // Вариант 3: Сохранение this в переменную
//     /*
//     const self = this;
//     this.students.forEach(function(student) {
//       console.log(${self.title}: ${student});
//     });
//     */
//   }
// };

// group.showList();
// // JavaScript Group: John
// // JavaScript Group: Jane
// // JavaScript Group: Alice


// ▎Задача 5: Преобразование объектов
// Создайте объект, который:
// 1. При преобразовании в число равен 42
// 2. При преобразовании в строку равен "Hello"
// 3. При сравнении с числами > 10 возвращает true

const magicObject = {
  // Ваш код
};

console.log(Number(magicObject)); // 42
console.log(String(magicObject)); // "Hello"
console.log(magicObject > 10);    // true
console.log(magicObject > 50);    // false


// Решение:
// const magicObject = {
//   valueOf() {
//     return 42;
//   },
//   toString() {
//     return "Hello";
//   }
// };

// console.log(Number(magicObject)); // 42
// console.log(String(magicObject)); // "Hello"
// console.log(magicObject > 10);    // true (42 > 10)
// console.log(magicObject > 50);    // false (42 > 50)


// ▎Задача 6: Сложное преобразование объектов
// Создайте объект, для которого:
// String(obj < 0) + String(obj > 0) === "truefalse"

const strangeObject = {
  // Ваш код
};

console.log(String(strangeObject < 0) + String(strangeObject > 0)); // "truefalse"


// Решение:
// const strangeObject = {
//   valueOf() {
//     // Если вызывается для сравнения с 0, возвращаем разные значения
//     const caller = new Error().stack;
//     if (caller.includes("strangeObject < 0")) {
//       return -1; // Для strangeObject < 0 вернет true
//     } else {
//       return 0;  // Для strangeObject > 0 вернет false
//     }
//   }
// };

// // Альтернативное решение с использованием счетчика
// const strangeObject2 = {
//   callCount: 0,
//   valueOf() {
//     this.callCount++;
//     // Первый вызов для strangeObject < 0, второй для strangeObject > 0
//     return this.callCount === 1 ? -1 : 0;
//   }
// };

// console.log(String(strangeObject < 0) + String(strangeObject > 0)); // "truefalse"
// console.log(String(strangeObject2 < 0) + String(strangeObject2 > 0)); // "truefalse"


// ▎Задача 7: Конструктор с контекстом
// Создайте конструктор Calculator, который создает объекты с методами:
// - read() - запрашивает

// ================▎3. Задачи от простого к сложному================